<!-- generated with roffit -->
<a name="NAME"></a><h2 class="nroffsh">Name</h2>
<p class="level0">libcurl-security - security considerations when using libcurl </p><a name="Security"></a><h2 class="nroffsh">Security</h2>
<p class="level0">The libcurl project takes security seriously. The library is written with caution and precautions are taken to mitigate many kinds of risks encountered while operating with potentially malicious servers on the Internet. It is a powerful library, however, which allows application writers to make trade-offs between ease of writing and exposure to potential risky operations. If used the right way, you can use libcurl to transfer data pretty safely. </p>
<p class="level0">Many applications are used in closed networks where users and servers can (possibly) be trusted, but many others are used on arbitrary servers and are fed input from potentially untrusted users. Following is a discussion about some risks in the ways in which applications commonly use libcurl and potential mitigations of those risks. It is not comprehensive, but shows classes of attacks that robust applications should consider. The Common Weakness Enumeration project at <a href="https://cwe.mitre.org/">https://cwe.mitre.org/</a> is a good reference for many of these and similar types of weaknesses of which application writers should be aware. </p><a name="Command"></a><h2 class="nroffsh">Command lines</h2>
<p class="level0">If you use a command line tool (such as curl) that uses libcurl, and you give options to the tool on the command line those options can get read by other users of your system when they use <span Class="emphasis">ps</span> or other tools to list currently running processes. </p>
<p class="level0">To avoid these problems, never feed sensitive things to programs using command line options. Write them to a protected file and use the -K option to avoid this. </p><a name="netrc"></a><h2 class="nroffsh">.netrc</h2>
<p class="level0">.netrc is a pretty handy file/feature that allows you to login quickly and automatically to frequently visited sites. The file contains passwords in clear text and is a real security risk. In some cases, your .netrc is also stored in a home directory that is NFS mounted or used on another network based file system, so the clear text password will fly through your network every time anyone reads that file. </p>
<p class="level0">For applications that enable .netrc use, a user who manage to set the right URL might then be possible to pass on passwords. </p>
<p class="level0">To avoid these problems, do not use .netrc files and never store passwords in plain text anywhere. </p><a name="Clear"></a><h2 class="nroffsh">Clear text passwords</h2>
<p class="level0">Many of the protocols libcurl supports send name and password unencrypted as clear text (HTTP Basic authentication, FTP, TELNET etc). It is easy for anyone on your network or a network nearby yours to just fire up a network analyzer tool and eavesdrop on your passwords. do not let the fact that HTTP Basic uses base64 encoded passwords fool you. They may not look readable at a first glance, but they are easily &quot;deciphered&quot; by anyone within seconds. </p>
<p class="level0">To avoid this problem, use an authentication mechanism or other protocol that does not let snoopers see your password: Digest, CRAM-MD5, Kerberos, SPNEGO or NTLM authentication. Or even better: use authenticated protocols that protect the entire connection and everything sent over it. </p><a name="Unauthenticated"></a><h2 class="nroffsh">Unauthenticated connections</h2>
<p class="level0">Protocols that do not have any form of cryptographic authentication cannot with any certainty know that they communicate with the right remote server. </p>
<p class="level0">If your application is using a fixed scheme or fixed host name, it is not safe as long as the connection is unauthenticated. There can be a man-in-the-middle or in fact the whole server might have been replaced by an evil actor. </p>
<p class="level0">Unauthenticated protocols are unsafe. The data that comes back to curl may have been injected by an attacker. The data that curl sends might be modified before it reaches the intended server. If it even reaches the intended server at all. </p>
<p class="level0">Remedies: </p>
<p class="level0"><a name="Restrict"></a><span class="nroffip">Restrict operations to authenticated transfers</span> </p>
<p class="level1">Use authenticated protocols protected with HTTPS or SSH. </p>
<p class="level0"><a name="Make"></a><span class="nroffip">Make sure the server&#39;s certificate etc is verified</span> </p>
<p class="level1">Never ever switch off certificate verification. </p><a name="Redirects"></a><h2 class="nroffsh">Redirects</h2>
<p class="level0">The <span Class="emphasis">CURLOPT_FOLLOWLOCATION(3)</span> option automatically follows HTTP redirects sent by a remote server. These redirects can refer to any kind of URL, not just HTTP. libcurl restricts the protocols allowed to be used in redirects for security reasons: only HTTP, HTTPS, FTP and FTPS are enabled by default. Applications may opt to restrict that set further. </p>
<p class="level0">A redirect to a file: URL would cause the libcurl to read (or write) arbitrary files from the local filesystem. If the application returns the data back to the user (as would happen in some kinds of CGI scripts), an attacker could leverage this to read otherwise forbidden data (e.g. <span Class="bold">file://localhost/etc/passwd</span>). </p>
<p class="level0">If authentication credentials are stored in the ~/.netrc file, or Kerberos is in use, any other URL type (not just file:) that requires authentication is also at risk. A redirect such as <a href="ftp://some-internal-server/private-file">ftp://some-internal-server/private-file</a> would then return data even when the server is password protected. </p>
<p class="level0">In the same way, if an unencrypted SSH private key has been configured for the user running the libcurl application, SCP: or SFTP: URLs could access password or private-key protected resources, e.g. <span Class="bold">sftp://user@some-internal-server/etc/passwd</span> </p>
<p class="level0">The <span Class="emphasis">CURLOPT_REDIR_PROTOCOLS(3)</span> and <span Class="emphasis">CURLOPT_NETRC(3)</span> options can be used to mitigate against this kind of attack. </p>
<p class="level0">A redirect can also specify a location available only on the machine running libcurl, including servers hidden behind a firewall from the attacker. e.g. <a href="http://127.0.0.1/">http://127.0.0.1/</a> or <a href="http://intranet/delete-stuff.cgi?delete=all">http://intranet/delete-stuff.cgi?delete=all</a> or tftp://bootp-server/pc-config-data </p>
<p class="level0">Applications can mitigate against this by disabling <span Class="emphasis">CURLOPT_FOLLOWLOCATION(3)</span> and handling redirects itself, sanitizing URLs as necessary. Alternately, an app could leave <span Class="emphasis">CURLOPT_FOLLOWLOCATION(3)</span> enabled but set <span Class="emphasis">CURLOPT_REDIR_PROTOCOLS(3)</span> and install a <span Class="emphasis">CURLOPT_OPENSOCKETFUNCTION(3)</span> or <span Class="emphasis">CURLOPT_PREREQFUNCTION(3)</span> callback function in which addresses are sanitized before use. </p><a name="CRLF"></a><h2 class="nroffsh">Crlf in headers</h2>
<p class="level0">For all options in libcurl which specify headers, including but not limited to <span Class="emphasis">CURLOPT_HTTPHEADER(3)</span>, <span Class="emphasis">CURLOPT_PROXYHEADER(3)</span>, <span Class="emphasis">CURLOPT_COOKIE(3)</span>, <span Class="emphasis">CURLOPT_USERAGENT(3)</span>, <span Class="emphasis">CURLOPT_REFERER(3)</span> and <span Class="emphasis">CURLOPT_RANGE(3)</span>, libcurl will send the headers as-is and will not apply any special sanitation or normalization to them. </p>
<p class="level0">If you allow untrusted user input into these options without sanitizing CRLF sequences in them, someone malicious may be able to modify the request in a way you did not intend such as injecting new headers. </p><a name="Local"></a><h2 class="nroffsh">Local resources</h2>
<p class="level0">A user who can control the DNS server of a domain being passed in within a URL can change the address of the host to a local, private address which a server-side libcurl-using application could then use. e.g. the innocuous URL <span Class="bold"><a href="http://fuzzybunnies.example.com/">http://fuzzybunnies.example.com/</a></span> could actually resolve to the IP address of a server behind a firewall, such as 127.0.0.1 or 10.1.2.3. Applications can mitigate against this by setting a <span Class="emphasis">CURLOPT_OPENSOCKETFUNCTION(3)</span> or <span Class="emphasis">CURLOPT_PREREQFUNCTION(3)</span> and checking the address before a connection. </p>
<p class="level0">All the malicious scenarios regarding redirected URLs apply just as well to non-redirected URLs, if the user is allowed to specify an arbitrary URL that could point to a private resource. For example, a web app providing a translation service might happily translate <span Class="bold">file://localhost/etc/passwd</span> and display the result. Applications can mitigate against this with the <span Class="emphasis">CURLOPT_PROTOCOLS(3)</span> option as well as by similar mitigation techniques for redirections. </p>
<p class="level0">A malicious FTP server could in response to the PASV command return an IP address and port number for a server local to the app running libcurl but behind a firewall. Applications can mitigate against this by using the <span Class="emphasis">CURLOPT_FTP_SKIP_PASV_IP(3)</span> option or <span Class="emphasis">CURLOPT_FTPPORT(3)</span>. </p>
<p class="level0">Local servers sometimes assume local access comes from friends and trusted users. An application that expects <a href="https://example.com/file_to_read">https://example.com/file_to_read</a> that and instead gets <a href="http://192.168.0.1/my_router_config">http://192.168.0.1/my_router_config</a> might print a file that would otherwise be protected by the firewall. </p>
<p class="level0">Allowing your application to connect to local hosts, be it the same machine that runs the application or a machine on the same local network, might be possible to exploit by an attacker who then perhaps can &quot;port-scan&quot; the particular hosts - depending on how the application and servers acts. </p><a name="IPv4"></a><h2 class="nroffsh">Ipv4 addresses</h2>
<p class="level0">Some users might be tempted to filter access to local resources or similar based on numerical IPv4 addresses used in URLs. This is a bad and error-prone idea because of the many different ways a numerical IPv4 address can be specified and libcurl accepts: one to four dot-separated fields using one of or a mix of decimal, octal or hexadecimal encoding. </p><a name="IPv6"></a><h2 class="nroffsh">Ipv6 addresses</h2>
<p class="level0">libcurl will normally handle IPv6 addresses transparently and just as easily as IPv4 addresses. That means that a sanitizing function that filters out addresses like 127.0.0.1 is not sufficient--the equivalent IPv6 addresses <span Class="bold">::1</span>, <span Class="bold">::</span>, <span Class="bold">0:00::0:1</span>, <span Class="bold">::127.0.0.1</span> and <span Class="bold">::ffff:7f00:1</span> supplied somehow by an attacker would all bypass a naive filter and could allow access to undesired local resources. IPv6 also has special address blocks like link-local and site-local that generally should not be accessed by a server-side libcurl-using application. A poorly configured firewall installed in a data center, organization or server may also be configured to limit IPv4 connections but leave IPv6 connections wide open. In some cases, setting <span Class="emphasis">CURLOPT_IPRESOLVE(3)</span> to CURL_IPRESOLVE_V4 can be used to limit resolved addresses to IPv4 only and bypass these issues. </p><a name="Uploads"></a><h2 class="nroffsh">Uploads</h2>
<p class="level0">When uploading, a redirect can cause a local (or remote) file to be overwritten. Applications must not allow any unsanitized URL to be passed in for uploads. Also, <span Class="emphasis">CURLOPT_FOLLOWLOCATION(3)</span> should not be used on uploads. Instead, the applications should consider handling redirects itself, sanitizing each URL first. </p><a name="Authentication"></a><h2 class="nroffsh">Authentication</h2>
<p class="level0">Use of <span Class="emphasis">CURLOPT_UNRESTRICTED_AUTH(3)</span> could cause authentication information to be sent to an unknown second server. Applications can mitigate against this by disabling <span Class="emphasis">CURLOPT_FOLLOWLOCATION(3)</span> and handling redirects itself, sanitizing where necessary. </p>
<p class="level0">Use of the CURLAUTH_ANY option to <span Class="emphasis">CURLOPT_HTTPAUTH(3)</span> could result in user name and password being sent in clear text to an HTTP server. Instead, use CURLAUTH_ANYSAFE which ensures that the password is encrypted over the network, or else fail the request. </p>
<p class="level0">Use of the CURLUSESSL_TRY option to <span Class="emphasis">CURLOPT_USE_SSL(3)</span> could result in user name and password being sent in clear text to an FTP server. Instead, use CURLUSESSL_CONTROL to ensure that an encrypted connection is used or else fail the request. </p><a name="Cookies"></a><h2 class="nroffsh">Cookies</h2>
<p class="level0">If cookies are enabled and cached, then a user could craft a URL which performs some malicious action to a site whose authentication is already stored in a cookie. e.g. <a href="http://mail.example.com/delete-stuff.cgi?delete=all">http://mail.example.com/delete-stuff.cgi?delete=all</a> Applications can mitigate against this by disabling cookies or clearing them between requests. </p><a name="Dangerous"></a><h2 class="nroffsh">Dangerous scp urls</h2>
<p class="level0">SCP URLs can contain raw commands within the scp: URL, which is a side effect of how the SCP protocol is designed. e.g. </p><pre class="level0">
&nbsp; scp://user:pass@host/a;date &gt;/tmp/test;
</pre>

<p class="level0">Applications must not allow unsanitized SCP: URLs to be passed in for downloads. </p><a name="file"></a><h2 class="nroffsh">File://</h2>
<p class="level0">By default curl and libcurl support file:// URLs. Such a URL is always an access, or attempted access, to a local resource. If your application wants to avoid that, keep control of what URLs to use and/or prevent curl/libcurl from using the protocol. </p>
<p class="level0">By default, libcurl prohibits redirects to file:// URLs. </p><a name="Warning"></a><h2 class="nroffsh">Warning: file:// on windows</h2>
<p class="level0">The Windows operating system will automatically, and without any way for applications to disable it, try to establish a connection to another host over the network and access it (over SMB or other protocols), if only the correct file path is accessed. </p>
<p class="level0">When first realizing this, the curl team tried to filter out such attempts in order to protect applications for inadvertent probes of for example internal networks etc. This resulted in CVE-2019-15601 and the associated security fix. </p>
<p class="level0">However, we have since been made aware of the fact that the previous fix was far from adequate as there are several other ways to accomplish more or less the same thing: accessing a remote host over the network instead of the local file system. </p>
<p class="level0">The conclusion we have come to is that this is a weakness or feature in the Windows operating system itself, that we as an application cannot safely protect users against. It would just be a whack-a-mole race we do not want to participate in. There are too many ways to do it and there&#39;s no knob we can use to turn off the practice. </p>
<p class="level0">If you use curl or libcurl on Windows (any version), disable the use of the FILE protocol in curl or be prepared that accesses to a range of &quot;magic paths&quot; will potentially make your system try to access other hosts on your network. curl cannot protect you against this. </p><a name="What"></a><h2 class="nroffsh">What if the user can set the url</h2>
<p class="level0">Applications may find it tempting to let users set the URL that it can work on. That is probably fine, but opens up for mischief and trickery that you as an application author may want to address or take precautions against. </p>
<p class="level0">If your curl-using script allow a custom URL do you also, perhaps unintentionally, allow the user to pass other options to the curl command line if creative use of special characters are applied? </p>
<p class="level0">If the user can set the URL, the user can also specify the scheme part to other protocols that you did not intend for users to use and perhaps did not consider. curl supports over 20 different URL schemes. &quot;<a href="http://&quot;">http://&quot;</a> might be what you thought, &quot;<a href="ftp://&quot;">ftp://&quot;</a> or &quot;imap://&quot; might be what the user gives your application. Also, cross-protocol operations might be done by using a particular scheme in the URL but point to a server doing a different protocol on a non-standard port. </p>
<p class="level0">Remedies: </p>
<p class="level0"><a name="Use"></a><span class="nroffip">Use --proto</span> </p>
<p class="level1">curl command lines can use <span Class="emphasis">--proto</span> to limit what URL schemes it accepts </p>
<p class="level0"><a name="Use"></a><span class="nroffip">Use CURLOPT_PROTOCOLS</span> </p>
<p class="level1">libcurl programs can use <span Class="emphasis">CURLOPT_PROTOCOLS(3)</span> to limit what URL schemes it accepts </p>
<p class="level0"><a name="consider"></a><span class="nroffip">consider not allowing the user to set the full URL</span> </p>
<p class="level1">Maybe just let the user provide data for parts of it? Or maybe filter input to only allow specific choices? </p><a name="RFC"></a><h2 class="nroffsh">Rfc 3986 vs whatwg url</h2>
<p class="level0">curl supports URLs mostly according to how they are defined in <a href="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986</a>, and has done so since the beginning. </p>
<p class="level0">Web browsers mostly adhere to the WHATWG URL Specification. </p>
<p class="level0">This deviance makes some URLs copied between browsers (or returned over HTTP for redirection) and curl not work the same way. It can also cause problems if an application parses URLs differently from libcurl and makes different assumptions about a link. This can mislead users into getting the wrong thing, connecting to the wrong host or otherwise not working identically. </p>
<p class="level0">Within an application, this can be mitigated by always using the <span Class="emphasis">curl_url(3)</span> API to parse URLs, ensuring that they are parsed the same way as within libcurl itself. </p><a name="FTP"></a><h2 class="nroffsh">Ftp uses two connections</h2>
<p class="level0">When performing an FTP transfer, two TCP connections are used: one for setting up the transfer and one for the actual data. </p>
<p class="level0">FTP is not only unauthenticated, but the setting up of the second transfer is also a weak spot. The second connection to use for data, is either setup with the PORT/EPRT command that makes the server connect back to the client on the given IP+PORT, or with PASV/EPSV that makes the server setup a port to listen to and tells the client to connect to a given IP+PORT. </p>
<p class="level0">Again, unauthenticated means that the connection might be meddled with by a man-in-the-middle or that there&#39;s a malicious server pretending to be the right one. </p>
<p class="level0">A malicious FTP server can respond to PASV commands with the IP+PORT of a totally different machine. Perhaps even a third party host, and when there are many clients trying to connect to that third party, it could create a Distributed Denial-Of-Service attack out of it. If the client makes an upload operation, it can make the client send the data to another site. If the attacker can affect what data the client uploads, it can be made to work as a HTTP request and then the client could be made to issue HTTP requests to third party hosts. </p>
<p class="level0">An attacker that manages to control curl&#39;s command line options can tell curl to send an FTP PORT command to ask the server to connect to a third party host instead of back to curl. </p>
<p class="level0">The fact that FTP uses two connections makes it vulnerable in a way that is hard to avoid. </p><a name="Denial"></a><h2 class="nroffsh">Denial of service</h2>
<p class="level0">A malicious server could cause libcurl to effectively hang by sending data slowly, or even no data at all but just keeping the TCP connection open. This could effectively result in a denial-of-service attack. The <span Class="emphasis">CURLOPT_TIMEOUT(3)</span> and/or <span Class="emphasis">CURLOPT_LOW_SPEED_LIMIT(3)</span> options can be used to mitigate against this. </p>
<p class="level0">A malicious server could cause libcurl to download an infinite amount of data, potentially causing all of memory or disk to be filled. Setting the <span Class="emphasis">CURLOPT_MAXFILESIZE_LARGE(3)</span> option is not sufficient to guard against this. Instead, applications should monitor the amount of data received within the write or progress callback and abort once the limit is reached. </p>
<p class="level0">A malicious HTTP server could cause an infinite redirection loop, causing a denial-of-service. This can be mitigated by using the <span Class="emphasis">CURLOPT_MAXREDIRS(3)</span> option. </p><a name="Arbitrary"></a><h2 class="nroffsh">Arbitrary headers</h2>
<p class="level0">User-supplied data must be sanitized when used in options like <span Class="emphasis">CURLOPT_USERAGENT(3)</span>, <span Class="emphasis">CURLOPT_HTTPHEADER(3)</span>, <span Class="emphasis">CURLOPT_POSTFIELDS(3)</span> and others that are used to generate structured data. Characters like embedded carriage returns or ampersands could allow the user to create additional headers or fields that could cause malicious transactions. </p><a name="Server-supplied"></a><h2 class="nroffsh">Server-supplied names</h2>
<p class="level0">A server can supply data which the application may, in some cases, use as a file name. The curl command-line tool does this with <span Class="emphasis">--remote-header-name</span>, using the Content-disposition: header to generate a file name. An application could also use <span Class="emphasis">CURLINFO_EFFECTIVE_URL(3)</span> to generate a file name from a server-supplied redirect URL. Special care must be taken to sanitize such names to avoid the possibility of a malicious server supplying one like <span Class="bold">&quot;/etc/passwd&quot;</span>, <span Class="bold">&quot;&bsol;autoexec.bat&quot;</span>, <span Class="bold">&quot;prn:&quot;</span> or even <span Class="bold">&quot;.bashrc&quot;</span>. </p><a name="Server"></a><h2 class="nroffsh">Server certificates</h2>
<p class="level0">A secure application should never use the <span Class="emphasis">CURLOPT_SSL_VERIFYPEER(3)</span> option to disable certificate validation. There are numerous attacks that are enabled by applications that fail to properly validate server TLS/SSL certificates, thus enabling a malicious server to spoof a legitimate one. HTTPS without validated certificates is potentially as insecure as a plain HTTP connection. </p><a name="Showing"></a><h2 class="nroffsh">Showing what you do</h2>
<p class="level0">Relatedly, be aware that in situations when you have problems with libcurl and ask someone for help, everything you reveal in order to get best possible help might also impose certain security related risks. Host names, user names, paths, operating system specifics, etc. (not to mention passwords of course) may in fact be used by intruders to gain additional information of a potential target. </p>
<p class="level0">Be sure to limit access to application logs if they could hold private or security-related data. Besides the obvious candidates like user names and passwords, things like URLs, cookies or even file names could also hold sensitive data. </p>
<p class="level0">To avoid this problem, you must of course use your common sense. Often, you can just edit out the sensitive data or just search/replace your true information with faked data. </p><a name="setuid"></a><h2 class="nroffsh">Setuid applications using libcurl</h2>
<p class="level0">libcurl-using applications that set the &#39;setuid&#39; bit to run with elevated or modified rights also implicitly give that extra power to libcurl and this should only be done after careful considerations. </p>
<p class="level0">Giving setuid powers to the application means that libcurl can save files using those new rights (if for example the `SSLKEYLOGFILE` environment variable is set). Also: if the application wants these powers to read or manage secrets that the user is otherwise not able to view (like credentials for a login etc), it should be noted that libcurl still might understand proxy environment variables that allow the user to redirect libcurl operations to use a proxy controlled by the user. </p><a name="File"></a><h2 class="nroffsh">File descriptors, fork and ntlm</h2>
<p class="level0">An application that uses libcurl and invokes <span Class="emphasis">fork()</span> will get all file descriptors duplicated in the child process, including the ones libcurl created. </p>
<p class="level0">libcurl itself uses <span Class="emphasis">fork()</span> and <span Class="emphasis">execl()</span> if told to use the <span Class="bold">CURLAUTH_NTLM_WB</span> authentication method which then will invoke the helper command in a child process with file descriptors duplicated. Make sure that only the trusted and reliable helper program is invoked! </p><a name="Secrets"></a><h2 class="nroffsh">Secrets in memory</h2>
<p class="level0">When applications pass user names, passwords or other sensitive data to libcurl to be used for upcoming transfers, those secrets will be kept around as-is in memory. In many cases they will be stored in heap for as long as the handle itself for which the options are set. </p>
<p class="level0">If an attacker can access the heap, like maybe by reading swap space or via a core dump file, such data might be accessible. </p>
<p class="level0">Further, when eventually closing a handle and the secrets are no longer needed, libcurl does not explicitly clear memory before freeing it, so credentials may be left in freed data. </p><a name="Report"></a><h2 class="nroffsh">Report security problems</h2>
<p class="level0">Should you detect or just suspect a security problem in libcurl or curl, contact the project curl security team immediately. See <a href="https://curl.se/dev/secprocess.html">https://curl.se/dev/secprocess.html</a> for details. </p><p class="roffit">
 This HTML page was made with <a href="http://daniel.haxx.se/projects/roffit/">roffit</a>.
