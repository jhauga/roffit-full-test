<!-- generated with roffit -->
<a name="NAME"></a><h2 class="nroffsh">Name</h2>
<p class="level0">libssh2_userauth_keyboard_interactive_ex - authenticate a session using keyboard-interactive authentication </p><a name="SYNOPSIS"></a><h2 class="nroffsh">Synopsis</h2><pre class="level0">
&#35;include &lt;libssh2.h&gt;
&nbsp;
int
libssh2_userauth_keyboard_interactive_ex(LIBSSH2_SESSION *session,
&nbsp;                                        const char *username,
&nbsp;                                        unsigned int username_len,
&nbsp;                  LIBSSH2_USERAUTH_KBDINT_RESPONSE_FUNC(*response_callback));
</pre>
<a name="DESCRIPTION"></a><h2 class="nroffsh">Description</h2>
<p class="level0"><span Class="emphasis">session</span> - Session instance as returned by <span Class="emphasis">libssh2_session_init_ex(3)</span>. </p>
<p class="level0"><span Class="emphasis">username</span> - Name of user to attempt keyboard-interactive authentication for. </p>
<p class="level0"><span Class="emphasis">username_len</span> - Length of username parameter. </p>
<p class="level0"><span Class="emphasis">response_callback</span> - As authentication proceeds, the host issues several (1 or more) challenges and requires responses. This callback will be called at this moment. The callback is responsible to obtain responses for the challenges, fill the provided data structure and then return control. Responses will be sent to the host. String values will be free(3)ed by the library. The callback prototype must match this: </p><pre class="level0">
void response(const char *name,
&nbsp;             int name_len, const char *instruction,
&nbsp;             int instruction_len,
&nbsp;             int num_prompts,
&nbsp;             const LIBSSH2_USERAUTH_KBDINT_PROMPT *prompts,
&nbsp;             LIBSSH2_USERAUTH_KBDINT_RESPONSE *responses,
&nbsp;             void **abstract);
</pre>

<p class="level0">Attempts keyboard-interactive (challenge/response) authentication. </p>
<p class="level0">Note that many SSH servers will always issue a single &quot;password&quot; challenge, requesting actual password as response, but it is not required by the protocol, and various authentication schemes, such as smartcard authentication may use keyboard-interactive authentication type too. </p><a name="RETURN"></a><h2 class="nroffsh">Return value</h2>
<p class="level0">Return 0 on success or negative on failure.  It returns LIBSSH2_ERROR_EAGAIN when it would otherwise block. While LIBSSH2_ERROR_EAGAIN is a negative number, it is not really a failure per se. </p><a name="ERRORS"></a><h2 class="nroffsh">Errors</h2>
<p class="level0"><span Class="emphasis">LIBSSH2_ERROR_ALLOC</span> -  An internal memory allocation call failed. </p>
<p class="level0"><span Class="emphasis">LIBSSH2_ERROR_SOCKET_SEND</span> - Unable to send data on socket. </p>
<p class="level0"><span Class="emphasis">LIBSSH2_ERROR_AUTHENTICATION_FAILED</span> - failed, invalid username/password or public/private key. </p><a name="SEE"></a><h2 class="nroffsh">See also</h2>
<p class="level0"><span Class="bold">libssh2_session_init_ex(3)</span> </p><p class="roffit">
 This HTML page was made with <a href="http://daniel.haxx.se/projects/roffit/">roffit</a>.
